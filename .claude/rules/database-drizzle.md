# Drizzle ORM Standards

## Core Configuration

### Drizzle Config

```typescript
// drizzle.config.ts
export default {
  schema: "./src/infrastructure/database/schemas/*.ts",
  out: "./src/infrastructure/database/migrations",
  dialect: "postgresql",
  dbCredentials: {
    // Use environment variables
  },
  migrations: {
    table: "drizzle_migrations",
    schema: "public",
  },
  verbose: true,
  strict: true,
} satisfies Config;
```

## Primary Key Standards

### ULID as Default ID

- **ALWAYS** use ULID for primary keys
- **NEVER** use auto-increment or UUID
- Import from `ulid` package

```typescript
import { ulid } from 'ulid';

// In schema definition
id: varchar('id', { length: 26 }).primaryKey(), // ULID is 26 chars

// In domain entity
import { ulid } from 'ulid';

export class OrganizationId {
  static create(): OrganizationId {
    return new OrganizationId(ulid());
  }
}
```

## Schema Definition Standards

### File Organization

```
src/
  infrastructure/
    database/
      schemas/
        organizations.schema.ts
        data-sources.schema.ts
        pipelines.schema.ts
        index.ts          // Re-export all schemas
      migrations/         // Generated by drizzle-kit
      seed/              // Seed data scripts
```

### Table Naming Conventions

```typescript
// Follow sql-database.mdc rules:
// - Tables: plural, snake_case
// - Columns: snake_case
// - Foreign keys: singular_table_name_id

export const organizations = pgTable("organizations", {
  id: varchar("id", { length: 26 }).primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  slug: varchar("slug", { length: 255 }).notNull().unique(),
  // Foreign keys
  owner_id: varchar("owner_id", { length: 26 }).references(() => users.id),
  // Timestamps (use timestamptz via withTimezone option)
  created_at: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updated_at: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
  deleted_at: timestamp("deleted_at", { withTimezone: true }), // Soft delete
});
```

### Column Types Mapping

| Domain Type | Drizzle Type                        | Notes                             |
| ----------- | ----------------------------------- | --------------------------------- |
| ID (ULID)   | `varchar(26)`                       | Always 26 chars                   |
| String      | `text()` or `varchar(n)`            | Use TEXT unless size limit needed |
| Boolean     | `boolean()`                         |                                   |
| Integer     | `integer()`                         |                                   |
| Decimal     | `numeric(precision, scale)`         | For money/percentages             |
| Date/Time   | `timestamp({ withTimezone: true })` | Use timezone-aware timestamps     |
| JSON        | `jsonb()`                           | Prefer jsonb over json            |
| Enum        | `pgEnum()`                          | Define enums separately           |

### Required Columns

Every table MUST include:

```typescript
created_at: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
updated_at: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
```

Tables with soft delete MUST include:

```typescript
deleted_at: timestamp('deleted_at', { withTimezone: true }),
```

### Indexes

```typescript
export const organizations = pgTable(
  "organizations",
  {
    // columns...
  },
  (table) => ({
    // Always index foreign keys
    ownerIdx: index("idx_organizations_owner_id").on(table.owner_id),
    // Index frequently queried columns
    slugIdx: index("idx_organizations_slug").on(table.slug),
    // Index soft delete column if present
    deletedAtIdx: index("idx_organizations_deleted_at").on(table.deleted_at),
    // Composite indexes for common queries
    orgOwnerIdx: index("idx_organizations_owner_deleted").on(table.owner_id, table.deleted_at),
  }),
);
```

### Relations

```typescript
import { relations } from "drizzle-orm";

export const organizationsRelations = relations(organizations, ({ one, many }) => ({
  owner: one(users, {
    fields: [organizations.owner_id],
    references: [users.id],
  }),
  dataSources: many(dataSources),
  pipelines: many(pipelines),
}));
```

## Repository Implementation

### Base Repository Pattern

```typescript
// src/infrastructure/repository/base-repository.ts
import { PostgresClient } from "@/infrastructure/persistence/drizzle";
import { and, eq, isNull } from "drizzle-orm";

export abstract class BaseRepository<TSchema> {
  protected db: PostgresClient["db"];
  protected table: any;

  constructor() {
    this.db = PostgresClient.getInstance().db;
  }

  async findById(id: string): Promise<TSchema | null> {
    const [result] = await this.db
      .select()
      .from(this.table)
      .where(and(eq(this.table.id, id), isNull(this.table.deleted_at)))
      .limit(1);

    return result || null;
  }

  async save(entity: TSchema): Promise<void> {
    await this.db
      .insert(this.table)
      .values(entity)
      .onConflictDoUpdate({
        target: this.table.id,
        set: {
          ...entity,
          updated_at: new Date(),
        },
      });
  }

  async delete(id: string): Promise<void> {
    await this.db
      .update(this.table)
      .set({
        deleted_at: new Date(),
        updated_at: new Date(),
      })
      .where(eq(this.table.id, id));
  }
}
```

### Specific Repository

```typescript
// src/infrastructure/repository/postgres-organization-repository.ts
import { organizations } from "@/infrastructure/persistence/drizzle/schema";
import { BaseRepository } from "@/infrastructure/repository";
import { eq, and, isNull } from "drizzle-orm";

export class OrganizationRepository extends BaseRepository<typeof organizations> {
  protected table = organizations;

  async findBySlug(slug: string): Promise<Organization | null> {
    const [result] = await this.db
      .select()
      .from(organizations)
      .where(and(eq(organizations.slug, slug), isNull(organizations.deleted_at)))
      .limit(1);

    return result ? this.toDomain(result) : null;
  }

  private toDomain(row: any): Organization {
    // Map database row to domain entity
    return Organization.restore({
      id: new OrganizationId(row.id),
      name: new OrganizationName(row.name),
      slug: new OrganizationSlug(row.slug),
      settings: row.settings,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  private toPersistence(entity: Organization): any {
    // Map domain entity to database row
    return {
      id: entity.id.value,
      name: entity.name.value,
      slug: entity.slug.value,
      settings: entity.settings,
      created_at: entity.createdAt,
      updated_at: entity.updatedAt,
    };
  }
}
```

## Query Builder Patterns

### Select Queries

```typescript
// NEVER use SELECT *
const users = await db
  .select({
    id: users.id,
    name: users.name,
    email: users.email,
  })
  .from(users)
  .where(eq(users.status, "active"))
  .orderBy(desc(users.created_at))
  .limit(10);
```

### Joins

```typescript
// Use explicit joins
const result = await db
  .select({
    org: organizations,
    owner: users,
  })
  .from(organizations)
  .innerJoin(users, eq(organizations.owner_id, users.id))
  .where(isNull(organizations.deleted_at));
```

### Transactions

```typescript
await db.transaction(async (tx) => {
  // Create organization
  await tx.insert(organizations).values(orgData);

  // Create default data source
  await tx.insert(dataSources).values(dataSourceData);

  // Create audit log
  await tx.insert(auditLogs).values(auditData);
});
```

### Raw SQL (When Necessary)

```typescript
import { sql } from "drizzle-orm";

// For complex queries or performance-critical operations
const result = await db.execute(sql`
  SELECT 
    o.id,
    o.name,
    COUNT(DISTINCT ds.id) as data_source_count,
    COUNT(DISTINCT p.id) as pipeline_count
  FROM organizations o
  LEFT JOIN data_sources ds ON ds.organization_id = o.id
  LEFT JOIN pipelines p ON p.organization_id = o.id
  WHERE o.deleted_at IS NULL
  GROUP BY o.id, o.name
  ORDER BY o.created_at DESC
`);
```

## Migrations

### Commands

```bash
# Generate migration from schema changes
bun run db:generate

# Apply migrations
bun run db:migrate

# Push schema (development only)
bun run db:push

# Open Drizzle Studio
bun run db:studio
```

### Migration Rules

- **NEVER** manually edit migration files in `/migrations/meta`
- **ALWAYS** review generated SQL before applying
- **ALWAYS** test migrations on development first
- **NEVER** use `db:push` in production
- Include both up and down migrations when complex

### Migration Naming

Generated files follow pattern: `0001_adjective_noun.sql`

## Performance Optimization

### Connection Pooling

```typescript
const client = postgres(DATABASE_URL, {
  max: 20, // Maximum connections
  idle_timeout: 20,
  connect_timeout: 10,
  prepare: false, // Disable prepared statements if needed
});
```

### Query Optimization

- Always include indexes on foreign keys
- Use composite indexes for common query patterns
- Prefer `jsonb` over `json` for better indexing
- Use `EXPLAIN ANALYZE` for slow queries
- Batch inserts when possible

### Caching Strategy

```typescript
// Use Redis for query result caching
import { redis } from '@/infrastructure/cache';

async findByIdCached(id: string): Promise<Organization | null> {
  const cacheKey = `org:${id}`;

  // Check cache
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }

  // Query database
  const result = await this.findById(id);

  // Cache result
  if (result) {
    await redis.setex(cacheKey, 300, JSON.stringify(result)); // 5 min TTL
  }

  return result;
}
```

## Testing with Drizzle

### Test Database Setup

```typescript
// tests/helpers/database.ts
import { drizzle } from "drizzle-orm/postgres-js";
import { migrate } from "drizzle-orm/postgres-js/migrator";

export async function setupTestDatabase() {
  const testDb = drizzle(postgres(TEST_DATABASE_URL));

  // Run migrations
  await migrate(testDb, {
    migrationsFolder: "./src/infrastructure/database/migrations",
  });

  // Clean all tables
  await testDb.execute(sql`TRUNCATE TABLE organizations CASCADE`);

  return testDb;
}
```

### Repository Testing

```typescript
describe("OrganizationRepository", () => {
  let repository: OrganizationRepository;
  let db: any;

  beforeEach(async () => {
    db = await setupTestDatabase();
    repository = new OrganizationRepository();
  });

  afterEach(async () => {
    await db.execute(sql`TRUNCATE TABLE organizations CASCADE`);
  });

  it("should save and retrieve organization", async () => {
    // Arrange
    const org = Organization.create({
      name: "Test Org",
      slug: "test-org",
    });

    // Act
    await repository.save(org);
    const retrieved = await repository.findById(org.id.value);

    // Assert
    expect(retrieved).toBeDefined();
    expect(retrieved?.name.value).toBe("Test Org");
  });
});
```

## Common Patterns

### Soft Delete Implementation

```typescript
// Always filter soft-deleted records
const activeOrgs = await db.select().from(organizations).where(isNull(organizations.deleted_at));

// Include deleted records when needed
const allOrgs = await db.select().from(organizations); // No deleted_at filter
```

### Pagination

```typescript
interface PaginationParams {
  page: number;
  pageSize: number;
}

async findPaginated({ page, pageSize }: PaginationParams) {
  const offset = (page - 1) * pageSize;

  const [items, [{ count }]] = await Promise.all([
    db.select()
      .from(organizations)
      .where(isNull(organizations.deleted_at))
      .limit(pageSize)
      .offset(offset),
    db.select({ count: count() })
      .from(organizations)
      .where(isNull(organizations.deleted_at)),
  ]);

  return {
    items,
    total: count,
    page,
    pageSize,
    totalPages: Math.ceil(count / pageSize),
  };
}
```

### Audit Logging

```typescript
// Automatic audit log on updates
async update(id: string, data: Partial<Organization>) {
  const original = await this.findById(id);

  await db.transaction(async (tx) => {
    // Update entity
    await tx.update(organizations)
      .set({
        ...data,
        updated_at: new Date(),
      })
      .where(eq(organizations.id, id));

    // Create audit log
    await tx.insert(auditLogs).values({
      id: ulid(),
      entity_type: 'organization',
      entity_id: id,
      action: 'update',
      before: original,
      after: data,
      user_id: getCurrentUserId(),
      created_at: new Date(),
    });
  });
}
```

## Security Best Practices

### SQL Injection Prevention

```typescript
// ALWAYS use parameterized queries
// ✅ GOOD - Parameterized
await db.select().from(users).where(eq(users.id, userId));

// ❌ BAD - String interpolation
await db.execute(sql`SELECT * FROM users WHERE id = ${userId}`);

// ✅ GOOD - Safe raw SQL with sql template
await db.execute(sql`
  SELECT * FROM users 
  WHERE id = ${userId}
`);
```

### Data Validation

```typescript
// Validate before persisting
const nameResult = OrganizationName.create(input.name);
if (nameResult.isFailure()) {
  throw new ValidationError(nameResult.error);
}

// Use Drizzle's built-in validation
const schema = z.object({
  name: z.string().min(1).max(255),
  email: z.string().email(),
});

const validated = schema.parse(input);
```

## Troubleshooting

### Common Issues

1. **ULID Generation**: Always use `ulid()` from the `ulid` package
2. **Timezone Issues**: Use timezone-aware timestamps (`withTimezone: true`)
3. **Migration Conflicts**: Never edit meta files, regenerate instead
4. **Connection Leaks**: Always use singleton pattern for database client
5. **Transaction Deadlocks**: Keep transactions short and ordered

### Debug Mode

```typescript
// Enable query logging
const db = drizzle(client, {
  logger: true,
  schema,
});
```

## DO NOT

- ❌ Use auto-increment IDs
- ❌ Use UUID instead of ULID
- ❌ Edit migration meta files manually
- ❌ Use `SELECT *` in production
- ❌ Skip soft delete checks
- ❌ Use `db:push` in production
- ❌ Store sensitive data unencrypted
- ❌ Interpolate strings in SQL queries
- ❌ Create tables without timestamps
- ❌ Skip transaction for multi-step operations

## ALWAYS

- ✅ Use ULID for all IDs
- ✅ Include created_at and updated_at
- ✅ Use soft deletes (deleted_at)
- ✅ Index foreign keys
- ✅ Use transactions for related operations
- ✅ Validate data before persisting
- ✅ Use connection pooling
- ✅ Test migrations on development first
- ✅ Use parameterized queries
- ✅ Follow snake_case for database names
